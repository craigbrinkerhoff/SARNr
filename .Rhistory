rounds_with_no_edits <- 0
edits <- 1
while (rounds_with_no_edits < 2) {
if (edits == 0) rounds_with_no_edits <- rounds_with_no_edits+1
if (rounds_with_no_edits == 2) break
edits <- 1
# run for every river segment
for (seg in 1:n_seg) {
n_sources <- length(which(to == from[seg]))
# check if the segment is headwaters (no inflowing segments)
if (n_sources == 0 && is.na(nUp[seg]) == 1) {
} else if (n_sources == 1 && is.na(nUp[seg]) != 1) {
# what to assign if only one inflowing segment
prev_seg <- from[seg]
row <- to == prev_seg
# if the current stream order DOES NOT EQUAL TO inflowing
# stream order
if (!strahler[seg] == strahler[row]){
strahler[seg] <- strahler[row]
edits <- edits+1
}
} else {
# what to do if more than one inflowing river segment
prev_segs <- which(to == from[seg])
str <- strahler[which(to == from[seg])]
# str <- vector("numeric", length = length(prev_segs))
# # get the strahler number of the incoming river segments
# for(pseg in 1:length(prev_segs)){
#   row <- to == prev_segs[pseg]
#   str[pseg] <- strahler[row]
# }
max_value <- max(str)
n_max_values <- table(str)[as.character(max_value)]
if (n_max_values == 1) {
if (!strahler[seg] == max_value) {
strahler[seg] <- max(str)
edits <- edits+1
}
} else {
if (!strahler[seg] == max_value+1) {
strahler[seg] <- max(str)+1
edits <- edits+1
}
}
}
}
edits <- edits-1
}
test <- any(names(river) == "STRAHLER")
if(test) {
river <- river[,-"STRAHLER"]
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
message("Replacing the existing column 'STRAHLER'.")
} else {
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
}
View(river)
plot(river$STRAHLER)
plot(river)
View(river)
river <- hydrography_shp
from <- river$from
to <- river$to
nUp <- river$nUp
n_seg <- nrow(river)
strahler <- rep(1, n_seg)
strahler <- rep(1, n_seg) #inital estimate of stream order
rounds_with_no_edits <- 0
edits <- 1
river <- hydrography_shp
from <- river$from
to <- river$to
nUp <- river$nUp
n_seg <- nrow(river)
strahler <- rep(1, n_seg) #inital estimate of stream order
rounds_with_no_edits <- 0
edits <- 1
while (rounds_with_no_edits < 2) { #run until no longer edited
if (edits == 0) rounds_with_no_edits <- rounds_with_no_edits+1
if (rounds_with_no_edits == 2) break
edits <- 1
# run for every river segment
for (seg in 1:n_seg) {
n_sources <- length(which(to == from[seg]))
# check if the segment is headwaters (no inflowing segments)
if (n_sources == 0 && is.na(nUp[seg]) == 1) {
#do nothing, leave as first order
} else if (n_sources == 1 && is.na(nUp[seg]) != 1) {
# if there is a single upstream reach
#prev_seg <- from[seg]
row <- from[which(to == from[seg])]
# if the current stream order DOES NOT EQUAL TO inflowing
# stream order
if (!strahler[seg] == strahler[row]){
strahler[seg] <- strahler[row]
edits <- edits+1
}
} else {
# if there are multiple inflowing reaches
prev_segs <- which(to == from[seg])
str <- strahler[which(to == from[seg])]
# str <- vector("numeric", length = length(prev_segs))
# # get the strahler number of the incoming river segments
# for(pseg in 1:length(prev_segs)){
#   row <- to == prev_segs[pseg]
#   str[pseg] <- strahler[row]
# }
max_value <- max(str)
n_max_values <- table(str)[as.character(max_value)]
if (n_max_values == 1) {
if (!strahler[seg] == max_value) {
strahler[seg] <- max(str)
edits <- edits+1
}
} else {
if (!strahler[seg] == max_value+1) {
strahler[seg] <- max(str)+1
edits <- edits+1
}
}
}
}
edits <- edits-1
}
test <- any(names(river) == "STRAHLER")
if(test) {
river <- river[,-"STRAHLER"]
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
message("Replacing the existing column 'STRAHLER'.")
} else {
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
}
View(river)
any(names(river) == "STRAHLER")
View(river)
t <- calcStrahlerOrder(hydrography_shp)
#' Calculate stream order along network
#'
#' @note: this function was adapted (and simplified) from the hydrostreamer R package implementation of strahler stream order in R (https://github.com/mkkallio/hydrostreamer)
#'
#' @name calcStrahlerOrder
#'
#' @param river: river networks as sf object
#'
#' @return sf object river network, with stream order as an attribute
calcStrahlerOrder <- function(river){
from <- river$from
to <- river$to
nUp <- river$nUp
n_seg <- nrow(river)
strahler <- rep(1, n_seg) #inital estimate of stream order
rounds_with_no_edits <- 0
edits <- 1
while (rounds_with_no_edits < 2) { #run until no longer edited
if (edits == 0) rounds_with_no_edits <- rounds_with_no_edits+1
if (rounds_with_no_edits == 2) break
edits <- 1
# run for every river segment
for (seg in 1:n_seg) {
n_sources <- length(which(to == from[seg]))
# check if the segment is headwaters (no inflowing segments)
if (n_sources == 0 && is.na(nUp[seg]) == 1) {
#do nothing, leave as first order
} else if (n_sources == 1 && is.na(nUp[seg]) != 1) {
# if there is a single upstream reach
#prev_seg <- from[seg]
row <- from[which(to == from[seg])]
# if the current stream order DOES NOT EQUAL TO inflowing
# stream order
if (!strahler[seg] == strahler[row]){
strahler[seg] <- strahler[row]
edits <- edits+1
}
} else {
# if there are multiple inflowing reaches
prev_segs <- which(to == from[seg])
str <- strahler[which(to == from[seg])]
max_value <- max(str)
n_max_values <- table(str)[as.character(max_value)]
if (n_max_values == 1) {
if (!strahler[seg] == max_value) {
strahler[seg] <- max(str)
edits <- edits+1
}
} else {
if (!strahler[seg] == max_value+1) {
strahler[seg] <- max(str)+1
edits <- edits+1
}
}
}
}
edits <- edits-1
}
#add to river network
test <- any(names(river) == "STRAHLER")
if(test) {
river <- river[,-"STRAHLER"]
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
message("Replacing the existing column 'STRAHLER'.")
} else {
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
}
return(river)
}
t <- calcStrahlerOrder(hydrography_shp)
View(t)
library(devtools)
library(roxygen2)
hydrography_shp <- calcStrahlerOrder(hydrography_shp)
hydrography_shp$length_m <- as.numeric(st_length(hydrography_shp)) #don;t know what the length already in there is, but it might not be meters and might not be in the right projection, so we just do it ourselves here
View(hydrography_shp)
hydrography_shp <- dplyr::select(hydrography_shp, c('from', 'to', 'reachID', 'STRAHLER', 'length_m', 'geometry'))
View(hydrography_shp)
colnames(hydrography_shp) <- c('frmNode', 'toNode', 'rchID', 'strOrdr', 'lngth_m', 'geometry')
rivnet_dem <- st_read('data/DEM_rivnet_33333_20201009_045732_0f17.shp') #DEM river networks
dem_domain <- rast('data/dem_fin_20201009_045732_0f17.tif') #dem downscaled to 3m
image <- rast('data/PSScene4Band-20201009_045732_0f17.tif') #3m PlanetScope image
rivnet_rs_rast <- sarn_classifyWater_unimodal(img = image,
dem = dem_domain,
maxElev = 4000) #water is ignored above this elevation (to remove snow/ice/glaciers)
data <- sarn_data(dem_network = rivnet_dem,
riverMask = rivnet_rs_rast,
dem = dem_domain) #create SARN object
joinedNetwork <- sarn_joinNetworks(data = data,
bufferSize=5) #join DEM and RS networks
trimmedNetwork <- sarn_trimNetworks(networks = joinedNetwork,
printOutput = 'Yes') #trim combined DEM/RS network
trimmedNetwork = trimmedNetwork$trimmedNetwork
dem = data$dem
riverMask = data$riverMask
lengthThresh = 50
printOutput = 'Yes'
printOutput <- ifelse(printOutput == 'yes' || printOutput == 'Yes', 1, 0)
#CREATE NETWORK TOPOLOGY (ROUTING TABLE) USING SFNETWORKS PACKAGE
#this also iteratively removes dangling segments shorter than the length threshold until non are left
flag <- 1
while(flag != 0){
hydrography <- as_sfnetwork(trimmedNetwork)
smoothed = convert(hydrography, to_spatial_smooth) #SMOOTH 'PSEUDO-NODES', I.E. DISSOLVE ALL RS/DEM SUB-REACHES WITHIN A TOPOLOGICALLY-DEFINED REACH
hydrography_shp <- smoothed %>%
activate("edges") %>%
st_as_sf() %>%
dplyr::select(-c('reachID', 'geometry'))
hydrography_shp$reachID <- 1:nrow(hydrography_shp)
#ADD NUMBER UPSTREAM RIVERS
nup <- group_by(hydrography_shp, to) %>%
summarise(nUp=n())
nup <- as.data.frame(nup)
nup <- dplyr::select(nup, 'to', 'nUp')
colnames(nup) <- c('from', 'nUp') #re-assign nUp to the next downstream reach
hydrography_shp <- left_join(hydrography_shp, nup, by='from')
hydrography_shp$length <- as.numeric(st_length(hydrography_shp))
eraseRivers <- hydrography_shp[hydrography_shp$length < lengthThresh & is.na(hydrography_shp$nUp) ==1 ,]
trimmedNetwork <- filter(hydrography_shp, reachID %notin% eraseRivers$reachID)
trimmedNetwork <- dplyr::select(trimmedNetwork, c('reachID', 'geometry'))
flag <- nrow(hydrography_shp) - nrow(trimmedNetwork)
if(printOutput == 1){
print(paste0('removed ', flag, ' artifical dangles'))
}
}
View(hydrography_shp)
hydrography_shp <- calcStrahlerOrder(hydrography_shp) #see src/utils.R
#' Calculate stream order along network
#'
#' @note: this function was adapted (and simplified) from the hydrostreamer R package implementation of strahler stream order in R (https://github.com/mkkallio/hydrostreamer)
#'
#' @name calcStrahlerOrder
#'
#' @param river: river networks as sf object
#'
#' @return sf object river network, with stream order as an attribute
calcStrahlerOrder <- function(river){
from <- river$from
to <- river$to
nUp <- river$nUp
n_seg <- nrow(river)
strahler <- rep(1, n_seg) #inital estimate of stream order
rounds_with_no_edits <- 0
edits <- 1
while (rounds_with_no_edits < 2) { #run until no longer edited
if (edits == 0) rounds_with_no_edits <- rounds_with_no_edits+1
if (rounds_with_no_edits == 2) break
edits <- 1
# run for every river segment
for (seg in 1:n_seg) {
n_sources <- length(which(to == from[seg]))
# check if the segment is headwaters (no inflowing segments)
if (n_sources == 0 && is.na(nUp[seg]) == 1) {
#do nothing, leave as first order
} else if (n_sources == 1 && is.na(nUp[seg]) != 1) {
# if there is a single upstream reach
#prev_seg <- from[seg]
row <- from[which(to == from[seg])]
# if the current stream order DOES NOT EQUAL TO inflowing
# stream order
if (!strahler[seg] == strahler[row]){
strahler[seg] <- strahler[row]
edits <- edits+1
}
} else {
# if there are multiple inflowing reaches
prev_segs <- which(to == from[seg])
str <- strahler[which(to == from[seg])]
max_value <- max(str)
n_max_values <- table(str)[as.character(max_value)]
if (n_max_values == 1) {
if (!strahler[seg] == max_value) {
strahler[seg] <- max(str)
edits <- edits+1
}
} else {
if (!strahler[seg] == max_value+1) {
strahler[seg] <- max(str)+1
edits <- edits+1
}
}
}
}
edits <- edits-1
}
#add to river network
test <- any(names(river) == "STRAHLER")
if(test) {
river <- river[,-"STRAHLER"]
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
message("Replacing the existing column 'STRAHLER'.")
} else {
river <- tibble::add_column(river,
STRAHLER = strahler,
.before=length(names(river)))
}
return(river)
}
hydrography_shp <- calcStrahlerOrder(hydrography_shp) #see src/utils.R
hydrography_shp$length_m <- as.numeric(st_length(hydrography_shp)) #don;t know what the length already in there is, but it might not be meters and might not be in the right projection, so we just do it ourselves here
hydrography_shp <- dplyr::select(hydrography_shp, c('from', 'to', 'reachID', 'STRAHLER', 'length_m', 'geometry'))
colnames(hydrography_shp) <- c('frmNode', 'toNode', 'rchID', 'strOrdr', 'lngth_m', 'geometry')
printOutput <- ifelse(printOutput == 'yes' || printOutput == 'Yes', 1, 0)
#CREATE NETWORK TOPOLOGY (ROUTING TABLE) USING SFNETWORKS
#this also iteratively removes dangling segments shorter than the length threshold until non are left
flag <- 1
while(flag != 0){
hydrography <- as_sfnetwork(trimmedNetwork)
smoothed = convert(hydrography, to_spatial_smooth) #SMOOTH 'PSEUDO-NODES', I.E. DISSOLVE ALL RS/DEM SUB-REACHES WITHIN A TOPOLOGICALLY-DEFINED REACH
hydrography_shp <- smoothed %>%
activate("edges") %>%
st_as_sf() %>%
dplyr::select(-c('reachID', 'geometry'))
hydrography_shp$reachID <- 1:nrow(hydrography_shp)
#ADD NUMBER UPSTREAM RIVERS
nup <- group_by(hydrography_shp, to) %>%
summarise(nUp=n())
nup <- as.data.frame(nup)
nup <- dplyr::select(nup, 'to', 'nUp')
colnames(nup) <- c('from', 'nUp') #re-assign nUp to the next downstream reach
hydrography_shp <- left_join(hydrography_shp, nup, by='from')
hydrography_shp$length <- as.numeric(st_length(hydrography_shp))
eraseRivers <- hydrography_shp[hydrography_shp$length < lengthThresh & is.na(hydrography_shp$nUp) ==1 ,]
trimmedNetwork <- filter(hydrography_shp, reachID %notin% eraseRivers$reachID)
trimmedNetwork <- dplyr::select(trimmedNetwork, c('reachID', 'geometry'))
flag <- nrow(hydrography_shp) - nrow(trimmedNetwork)
if(printOutput == 1){
print(paste0('removed ', flag, ' artifical dangles'))
}
}
rm(hydrography)
rm(hydrography_shp)
#CREATE NETWORK TOPOLOGY (ROUTING TABLE) USING SFNETWORKS
#this also iteratively removes dangling segments shorter than the length threshold until non are left
flag <- 1
while(flag != 0){
hydrography <- as_sfnetwork(trimmedNetwork)
smoothed = convert(hydrography, to_spatial_smooth) #SMOOTH 'PSEUDO-NODES', I.E. DISSOLVE ALL RS/DEM SUB-REACHES WITHIN A TOPOLOGICALLY-DEFINED REACH
hydrography_shp <- smoothed %>%
activate("edges") %>%
st_as_sf() %>%
dplyr::select(-c('reachID', 'geometry'))
hydrography_shp$reachID <- 1:nrow(hydrography_shp)
#ADD NUMBER UPSTREAM RIVERS
nup <- group_by(hydrography_shp, to) %>%
summarise(nUp=n())
nup <- as.data.frame(nup)
nup <- dplyr::select(nup, 'to', 'nUp')
colnames(nup) <- c('from', 'nUp') #re-assign nUp to the next downstream reach
hydrography_shp <- left_join(hydrography_shp, nup, by='from')
hydrography_shp$length <- as.numeric(st_length(hydrography_shp))
eraseRivers <- hydrography_shp[hydrography_shp$length < lengthThresh & is.na(hydrography_shp$nUp) ==1 ,]
trimmedNetwork <- filter(hydrography_shp, reachID %notin% eraseRivers$reachID)
trimmedNetwork <- dplyr::select(trimmedNetwork, c('reachID', 'geometry'))
flag <- nrow(hydrography_shp) - nrow(trimmedNetwork)
if(printOutput == 1){
print(paste0('removed ', flag, ' artifical dangles'))
}
}
View(trimmedNetwork)
hydrography_shp$length_m <- as.numeric(st_length(hydrography_shp)) #don;t know what the length already in there is, but it might not be meters and might not be in the right projection, so we just do it ourselves here
hydrography_shp <- dplyr::select(hydrography_shp, c('from', 'to', 'reachID', 'STRAHLER', 'length_m', 'geometry'))
colnames(hydrography_shp) <- c('frmNode', 'toNode', 'rchID', 'strOrdr', 'lngth_m', 'geometry')
hydrography_shp <- dplyr::select(hydrography_shp, c('from', 'to', 'reachID', 'length_m', 'geometry'))
View(hydrography_shp)
rm(hydrography_shp)
rm(hydrography)
rm(flag)
printOutput <- ifelse(printOutput == 'yes' || printOutput == 'Yes', 1, 0)
#CREATE NETWORK TOPOLOGY (ROUTING TABLE) USING SFNETWORKS
#this also iteratively removes dangling segments shorter than the length threshold until non are left
flag <- 1
while(flag != 0){
hydrography <- as_sfnetwork(trimmedNetwork)
smoothed = convert(hydrography, to_spatial_smooth) #SMOOTH 'PSEUDO-NODES', I.E. DISSOLVE ALL RS/DEM SUB-REACHES WITHIN A TOPOLOGICALLY-DEFINED REACH
hydrography_shp <- smoothed %>%
activate("edges") %>%
st_as_sf() %>%
dplyr::select(-c('reachID', 'geometry'))
hydrography_shp$reachID <- 1:nrow(hydrography_shp)
#ADD NUMBER UPSTREAM RIVERS
nup <- group_by(hydrography_shp, to) %>%
summarise(nUp=n())
nup <- as.data.frame(nup)
nup <- dplyr::select(nup, 'to', 'nUp')
colnames(nup) <- c('from', 'nUp') #re-assign nUp to the next downstream reach
hydrography_shp <- left_join(hydrography_shp, nup, by='from')
hydrography_shp$length <- as.numeric(st_length(hydrography_shp))
eraseRivers <- hydrography_shp[hydrography_shp$length < lengthThresh & is.na(hydrography_shp$nUp) ==1 ,]
trimmedNetwork <- filter(hydrography_shp, reachID %notin% eraseRivers$reachID)
trimmedNetwork <- dplyr::select(trimmedNetwork, c('reachID', 'geometry'))
flag <- nrow(hydrography_shp) - nrow(trimmedNetwork)
if(printOutput == 1){
print(paste0('removed ', flag, ' artifical dangles'))
}
}
rm(trimmedNetwork)
rm(nup)
rm(hydrography)
rm(hydrography_shp)
rm(dem)
rm(eraseRivers)
rm(riverMask)
rm(flag)
rm(lengthThresh)
rm(calcStrahlerOrder())
rm(calcStrahlerOrder)
rm(printOutput)
trimmedNetwork <- sarn_trimNetworks(networks = joinedNetwork,
printOutput = 'Yes') #trim combined DEM/RS network
rm(smoothed)
load_all()
fin <- sarn_hydrography(trimmedNetwork = trimmedNetwork$trimmedNetwork,
dem = data$dem,
riverMask = data$riverMask,
lengthThresh = 50,
printOutput = 'Yes') #build hydrography
load_all()
fin <- sarn_hydrography(trimmedNetwork = trimmedNetwork$trimmedNetwork,
dem = data$dem,
riverMask = data$riverMask,
lengthThresh = 50,
printOutput = 'Yes') #build hydrography
load_all()
fin <- sarn_hydrography(trimmedNetwork = trimmedNetwork$trimmedNetwork,
dem = data$dem,
riverMask = data$riverMask,
lengthThresh = 50,
printOutput = 'Yes') #build hydrography
load_all()
fin <- sarn_hydrography(trimmedNetwork = trimmedNetwork$trimmedNetwork,
dem = data$dem,
riverMask = data$riverMask,
lengthThresh = 50,
printOutput = 'Yes') #build hydrography
load_all()
fin <- sarn_hydrography(trimmedNetwork = trimmedNetwork$trimmedNetwork,
dem = data$dem,
riverMask = data$riverMask,
lengthThresh = 50,
printOutput = 'Yes') #build hydrography
View(fin)
roxygenise()
roxygenise()
load_all()
roxygenise()
library(testthat)
document()
test_coverage()
library(devtools)
test_coverage()
usethis::use_test("SARNr")
usethis::use_test()
usethis::use_testthat()
library(usethis)
usethis::use_gpl3_license(name = "Craig Brinkerhoff") # derivatives must be open
usethis::use_test("sarn_data")
usethis::use_test("sarn_data")
library(testthat)
library(devtools)
build_site()
build_vignettes()
